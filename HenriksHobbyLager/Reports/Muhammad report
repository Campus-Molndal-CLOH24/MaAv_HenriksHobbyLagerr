# Individuell Rapport

## Muhammad Aamir Hussain

# Hur fungerade gruppens arbete?
## Vår grupp fungerade bra eftersom vi hade en öppen dialog och hjälptes åt när vi stötte på problem. 
Jag var med från början och deltog i diskussioner om hur vi skulle lösa olika delar av projektet. 
Det var ibland svårt att hänga med eftersom jag studerade både grundläggande och mer avancerade ämnen samtidigt, men gruppen var stöttande och hjälpte till när det behövdes. 
Alla bidrog på sitt sätt, och vi fick en färdig produkt som fungerade bra till slut.

# Beskriv gruppens databasimplementation
## Jag har ännu inte haft kursen om databaser, så jag deltog inte i själva implementeringen av databasen. 
Däremot var jag med och diskuterade lösningar och försökte förstå hur den skulle fungera. 
Från början hade vi en fysisk databasfil på systemet, men det behövde ändras till en implementation via kod i Visual Studio.
Avinash tog över den delen och löste det på ett bra sätt, vilket jag lärde mig mycket av genom att följa processen.

# Vilka SOLID-principer implementerade ni och hur?
## Jag är fortfarande nybörjare på att förstå SOLID-principerna fullt ut, men jag märkte hur vi följde några av dem i vår kod. 

Single Responsibility Principle (SRP): Vi separerade ansvaret i olika klasser. Till exempel hade vi en klass för att hantera själva programlogiken och en annan för att interagera med databasen.
Open/Closed Principle (OCP): Vår kod kunde utökas utan att behöva ändras i grunden, vilket jag förstod var en viktig princip.
Dependency Inversion Principle (DIP): Vi använde dependency injection för att hantera beroenden mellan olika delar av koden.
Det var svårt att greppa allt i början, men med hjälp av gruppen och lite extra research kunde jag förstå hur principerna tillämpades i vårt projekt.


# Vilka patterns använde ni och varför?
## Vi använde flera designmönster i projektet, även om jag inte var medveten om alla namn från början. Här är några av de mönster vi använde:

Repository Pattern: För att separera databasanrop från programlogiken.
Unit of Work (Implicit): Detta hjälpte till att hantera flera databasoperationer som en enhet.
CRUD Pattern: Vi implementerade de grundläggande operationerna (Create, Read, Update, Delete) för vår databas.
Dependency Injection: Detta användes för att göra koden mer flexibel och testbar.

# Vilka tekniska utmaningar stötte ni på och hur löste ni dem?
## En av de största utmaningarna var att databasen först var en fysisk fil på systemet och att detta behövde ändras till en kodbaserad implementation i Visual Studio. 
Det här var något jag inte kunde bidra mycket till, men jag såg hur Avinash löste det, vilket var lärorikt.

En annan utmaning för mig personligen var att förstå och använda GitHub-kommandon. 
Jag tog hjälp av gruppmedlemmar och lärde mig hur man klonar ett projekt, gör commits och pushar ändringar.
Det var också en utmaning att arbeta med både grundläggande och mer avancerade koncept samtidigt, men det gav mig en bredare förståelse.

# Vilka delar gjorde du?
##
-Deltog i diskussioner och problemlösningar.
-Försökte förstå koden och testade den för att se hur den fungerade.
-Lärde mig och använde GitHub-kommandon för att bidra till projektet.
-Bidrog med att ge feedback och idéer under arbetets gång.


# Vad skulle du göra annorlunda nästa gång?
## 
-Försöka planera min tid bättre och sätta av mer tid för att förstå detaljerna.
-Våga fråga ännu mer när jag inte förstår något.
-Lägga mer fokus på att lära mig de tekniska verktygen som används, som GitHub och databashantering.
-Vara mer aktiv i att bidra, även om jag känner att jag inte kan så mycket än.
-Använda någon form av struktur, som en kanban-tavla, för att hålla koll på vad som behöver göras.
